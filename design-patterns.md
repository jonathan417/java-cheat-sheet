# Java Design Patterns

## SOLID Principles

| Principle             | Description                                                                                   | Example                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| --------------------- | --------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Single Responsibility | A class should have only one reason to change.<br>• Separates concerns<br>• Improves maintainability<br>• Makes code more readable | `// Bad: Multiple responsibilities`<br>`class User {`<br>&nbsp;&nbsp;`private String name;`<br>&nbsp;&nbsp;`public void saveToDatabase() { /*...*/ }`<br>&nbsp;&nbsp;`public void generateReport() { /*...*/ }`<br>`}`<br><br>`// Good: Single responsibility`<br>`class User {`<br>&nbsp;&nbsp;`private String name;`<br>&nbsp;&nbsp;`// Only user properties and behaviors`<br>`}`<br>`class UserRepository {`<br>&nbsp;&nbsp;`public void save(User user) { /*...*/ }`<br>`}`<br>`class ReportGenerator {`<br>&nbsp;&nbsp;`public void generateUserReport(User user) { /*...*/ }`<br>`}`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Open/Closed           | Software entities should be open for extension but closed for modification.<br>• Reduces modification risk<br>• Promotes interface usage<br>• Supports polymorphism | `// Bad: Need to modify class when adding new shapes`<br>`class AreaCalculator {`<br>&nbsp;&nbsp;`double calculateArea(Object shape) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;`if (shape instanceof Rectangle) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`Rectangle rect = (Rectangle) shape;`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`return rect.width * rect.height;`<br>&nbsp;&nbsp;&nbsp;&nbsp;`} else if (shape instanceof Circle) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`Circle circle = (Circle) shape;`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`return Math.PI * circle.radius * circle.radius;`<br>&nbsp;&nbsp;&nbsp;&nbsp;`}`<br>&nbsp;&nbsp;&nbsp;&nbsp;`return 0;`<br>&nbsp;&nbsp;`}`<br>`}`<br><br>`// Good: Open for extension, closed for modification`<br>`interface Shape {`<br>&nbsp;&nbsp;`double calculateArea();`<br>`}`<br>`class Rectangle implements Shape {`<br>&nbsp;&nbsp;`double width, height;`<br>&nbsp;&nbsp;`public double calculateArea() {`<br>&nbsp;&nbsp;&nbsp;&nbsp;`return width * height;`<br>&nbsp;&nbsp;`}`<br>`}`<br>`class Circle implements Shape {`<br>&nbsp;&nbsp;`double radius;`<br>&nbsp;&nbsp;`public double calculateArea() {`<br>&nbsp;&nbsp;&nbsp;&nbsp;`return Math.PI * radius * radius;`<br>&nbsp;&nbsp;`}`<br>`}`<br>`class AreaCalculator {`<br>&nbsp;&nbsp;`double calculateArea(Shape shape) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;`return shape.calculateArea();`<br>&nbsp;&nbsp;`}`<br>`}` |
| Liskov Substitution   | Subtypes must be substitutable for their base types.<br>• Ensures correct inheritance<br>• Prevents unexpected behavior<br>• Prevents violating client expectations | `// Bad: Square is not substitutable for Rectangle`<br>`class Rectangle {`<br>&nbsp;&nbsp;`protected int width, height;`<br>&nbsp;&nbsp;`public void setWidth(int width) { this.width = width; }`<br>&nbsp;&nbsp;`public void setHeight(int height) { this.height = height; }`<br>`}`<br>`class Square extends Rectangle {`<br>&nbsp;&nbsp;`@Override`<br>&nbsp;&nbsp;`public void setWidth(int width) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;`this.width = width;`<br>&nbsp;&nbsp;&nbsp;&nbsp;`this.height = width; // Violates LSP`<br>&nbsp;&nbsp;`}`<br>&nbsp;&nbsp;`@Override`<br>&nbsp;&nbsp;`public void setHeight(int height) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;`this.width = height; // Violates LSP`<br>&nbsp;&nbsp;&nbsp;&nbsp;`this.height = height;`<br>&nbsp;&nbsp;`}`<br>`}`<br><br>`// Good: Use composition or interfaces`<br>`interface Shape {`<br>&nbsp;&nbsp;`int area();`<br>`}`<br>`class Rectangle implements Shape {`<br>&nbsp;&nbsp;`private int width, height;`<br>&nbsp;&nbsp;`// getters and setters`<br>&nbsp;&nbsp;`public int area() { return width * height; }`<br>`}`<br>`class Square implements Shape {`<br>&nbsp;&nbsp;`private int side;`<br>&nbsp;&nbsp;`// getters and setters`<br>&nbsp;&nbsp;`public int area() { return side * side; }`<br>`}`                                                                                                                                                               |
| Interface Segregation | Clients should not be forced to depend on interfaces they do not use.<br>• Creates focused interfaces<br>• Reduces coupling<br>• Prevents bloated interfaces | `// Bad: Fat interface`<br>`interface Worker {`<br>&nbsp;&nbsp;`void work();`<br>&nbsp;&nbsp;`void eat();`<br>&nbsp;&nbsp;`void sleep();`<br>`}`<br>`class Human implements Worker {`<br>&nbsp;&nbsp;`public void work() { /*...*/ }`<br>&nbsp;&nbsp;`public void eat() { /*...*/ }`<br>&nbsp;&nbsp;`public void sleep() { /*...*/ }`<br>`}`<br>`class Robot implements Worker {`<br>&nbsp;&nbsp;`public void work() { /*...*/ }`<br>&nbsp;&nbsp;`public void eat() { /* Robot can't eat! */ }`<br>&nbsp;&nbsp;`public void sleep() { /* Robot doesn't sleep! */ }`<br>`}`<br><br>`// Good: Segregated interfaces`<br>`interface Workable {`<br>&nbsp;&nbsp;`void work();`<br>`}`<br>`interface Eatable {`<br>&nbsp;&nbsp;`void eat();`<br>`}`<br>`interface Sleepable {`<br>&nbsp;&nbsp;`void sleep();`<br>`}`<br>`class Human implements Workable, Eatable, Sleepable {`<br>&nbsp;&nbsp;`public void work() { /*...*/ }`<br>&nbsp;&nbsp;`public void eat() { /*...*/ }`<br>&nbsp;&nbsp;`public void sleep() { /*...*/ }`<br>`}`<br>`class Robot implements Workable {`<br>&nbsp;&nbsp;`public void work() { /*...*/ }`<br>`}`                                                                                                                                                                                                                                                                                                            |
| Dependency Inversion  | High-level modules should not depend on low-level modules. Both should depend on abstractions.<br>• Decouples components<br>• Facilitates testing<br>• Allows multiple implementations | `// Bad: Direct dependency on concrete class`<br>`class ReportGenerator {`<br>&nbsp;&nbsp;`private MySQLDatabase database;`<br>&nbsp;&nbsp;`public ReportGenerator() {`<br>&nbsp;&nbsp;&nbsp;&nbsp;`this.database = new MySQLDatabase();`<br>&nbsp;&nbsp;`}`<br>&nbsp;&nbsp;`public void generateReport() {`<br>&nbsp;&nbsp;&nbsp;&nbsp;`database.getData();`<br>&nbsp;&nbsp;&nbsp;&nbsp;`// process data`<br>&nbsp;&nbsp;`}`<br>`}`<br><br>`// Good: Dependency on abstraction`<br>`interface Database {`<br>&nbsp;&nbsp;`Data getData();`<br>`}`<br>`class MySQLDatabase implements Database {`<br>&nbsp;&nbsp;`public Data getData() { /*...*/ }`<br>`}`<br>`class MongoDatabase implements Database {`<br>&nbsp;&nbsp;`public Data getData() { /*...*/ }`<br>`}`<br>`class ReportGenerator {`<br>&nbsp;&nbsp;`private Database database;`<br>&nbsp;&nbsp;`// Injection through constructor`<br>&nbsp;&nbsp;`public ReportGenerator(Database database) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;`this.database = database;`<br>&nbsp;&nbsp;`}`<br>&nbsp;&nbsp;`public void generateReport() {`<br>&nbsp;&nbsp;&nbsp;&nbsp;`database.getData();`<br>&nbsp;&nbsp;&nbsp;&nbsp;`// process data`<br>&nbsp;&nbsp;`}`<br>`}`                                                                                                                                                                                                                             |

## Creational Patterns

| Pattern          | Description                                               | Example                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| ---------------- | --------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Singleton        | Single instance of class.<br>• Ensures global access point<br>• Controls instantiation<br>• Lazy or eager initialization options | `public class Singleton {`<br>&nbsp;&nbsp;`private static Singleton instance;`<br>&nbsp;&nbsp;`private Singleton() {}`<br>&nbsp;&nbsp;`public static synchronized Singleton getInstance() {`<br>&nbsp;&nbsp;&nbsp;&nbsp;`if (instance == null) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`instance = new Singleton();`<br>&nbsp;&nbsp;&nbsp;&nbsp;`}`<br>&nbsp;&nbsp;&nbsp;&nbsp;`return instance;`<br>&nbsp;&nbsp;`}`<br>`}`<br><br>`// Thread-safe with double-check locking`<br>`public class Singleton {`<br>&nbsp;&nbsp;`private static volatile Singleton instance;`<br>&nbsp;&nbsp;`private Singleton() {}`<br>&nbsp;&nbsp;`public static Singleton getInstance() {`<br>&nbsp;&nbsp;&nbsp;&nbsp;`if (instance == null) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`synchronized (Singleton.class) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`if (instance == null) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`instance = new Singleton();`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`}`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`}`<br>&nbsp;&nbsp;&nbsp;&nbsp;`}`<br>&nbsp;&nbsp;&nbsp;&nbsp;`return instance;`<br>&nbsp;&nbsp;`}`<br>`}`                             |
| Factory          | Create objects without specifying exact class.<br>• Hides implementation details<br>• Centralizes object creation<br>• Defers to subclasses | `public interface Shape { void draw(); }`<br>`public class Circle implements Shape { public void draw() { } }`<br>`public class Rectangle implements Shape { public void draw() { } }`<br>`public class ShapeFactory {`<br>&nbsp;&nbsp;`public Shape getShape(String type) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;`if (type.equals("CIRCLE")) return new Circle();`<br>&nbsp;&nbsp;&nbsp;&nbsp;`if (type.equals("RECTANGLE")) return new Rectangle();`<br>&nbsp;&nbsp;&nbsp;&nbsp;`return null;`<br>&nbsp;&nbsp;`}`<br>`}`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| Abstract Factory | Create families of related objects.<br>• Platform independence<br>• Enforces consistency in object families<br>• More flexible than factory | `interface Button { void paint(); }`<br>`interface Checkbox { void paint(); }`<br><br>`class MacButton implements Button { public void paint() { /*...*/ } }`<br>`class MacCheckbox implements Checkbox { public void paint() { /*...*/ } }`<br>`class WindowsButton implements Button { public void paint() { /*...*/ } }`<br>`class WindowsCheckbox implements Checkbox { public void paint() { /*...*/ } }`<br><br>`interface GUIFactory {`<br>&nbsp;&nbsp;`Button createButton();`<br>&nbsp;&nbsp;`Checkbox createCheckbox();`<br>`}`<br><br>`class MacFactory implements GUIFactory {`<br>&nbsp;&nbsp;`public Button createButton() { return new MacButton(); }`<br>&nbsp;&nbsp;`public Checkbox createCheckbox() { return new MacCheckbox(); }`<br>`}`<br><br>`class WindowsFactory implements GUIFactory {`<br>&nbsp;&nbsp;`public Button createButton() { return new WindowsButton(); }`<br>&nbsp;&nbsp;`public Checkbox createCheckbox() { return new WindowsCheckbox(); }`<br>`}`                                                                                                                                                                                                                               |
| Builder          | Construct complex objects step by step.<br>• Separates construction from representation<br>• Same process for different representations<br>• Fine control over construction | `public class Person {`<br>&nbsp;&nbsp;`private String name;`<br>&nbsp;&nbsp;`private int age;`<br>&nbsp;&nbsp;`private Person(Builder builder) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;`this.name = builder.name;`<br>&nbsp;&nbsp;&nbsp;&nbsp;`this.age = builder.age;`<br>&nbsp;&nbsp;`}`<br>&nbsp;&nbsp;`public static class Builder {`<br>&nbsp;&nbsp;&nbsp;&nbsp;`private String name;`<br>&nbsp;&nbsp;&nbsp;&nbsp;`private int age;`<br>&nbsp;&nbsp;&nbsp;&nbsp;`public Builder name(String name) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`this.name = name;`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`return this;`<br>&nbsp;&nbsp;&nbsp;&nbsp;`}`<br>&nbsp;&nbsp;&nbsp;&nbsp;`public Builder age(int age) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`this.age = age;`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`return this;`<br>&nbsp;&nbsp;&nbsp;&nbsp;`}`<br>&nbsp;&nbsp;&nbsp;&nbsp;`public Person build() {`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`return new Person(this);`<br>&nbsp;&nbsp;&nbsp;&nbsp;`}`<br>&nbsp;&nbsp;`}`<br>`}`<br>`// Usage`<br>`Person person = new Person.Builder()`<br>&nbsp;&nbsp;&nbsp;&nbsp;`.name("John")`<br>&nbsp;&nbsp;&nbsp;&nbsp;`.age(30)`<br>&nbsp;&nbsp;&nbsp;&nbsp;`.build();` |
| Prototype        | Clone existing objects without depending on their classes.<br>• Avoids subclassing for object creation<br>• Reduces initialization cost<br>• Creates objects with varying state | `interface Prototype<T> {`<br>&nbsp;&nbsp;`T clone();`<br>`}`<br><br>`class User implements Prototype<User> {`<br>&nbsp;&nbsp;`private String name;`<br>&nbsp;&nbsp;`private int age;`<br>&nbsp;&nbsp;`// constructor, getters, setters`<br>&nbsp;&nbsp;`@Override`<br>&nbsp;&nbsp;`public User clone() {`<br>&nbsp;&nbsp;&nbsp;&nbsp;`User copy = new User();`<br>&nbsp;&nbsp;&nbsp;&nbsp;`copy.name = this.name;`<br>&nbsp;&nbsp;&nbsp;&nbsp;`copy.age = this.age;`<br>&nbsp;&nbsp;&nbsp;&nbsp;`return copy;`<br>&nbsp;&nbsp;`}`<br>`}`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |

## Structural Patterns

| Pattern | Description | Example |
|---------|-------------|---------|
| Adapter | Interface compatibility between classes.<br>• Connects incompatible interfaces<br>• Reuses existing code<br>• Acts as a wrapper | `public interface MediaPlayer {`<br>&nbsp;&nbsp;`void play(String audioType, String fileName);`<br>`}`<br>`public interface AdvancedMediaPlayer {`<br>&nbsp;&nbsp;`void playMp4(String fileName);`<br>&nbsp;&nbsp;`void playVlc(String fileName);`<br>`}`<br>`public class MediaAdapter implements MediaPlayer {`<br>&nbsp;&nbsp;`AdvancedMediaPlayer advancedMusicPlayer;`<br>&nbsp;&nbsp;`public MediaAdapter(String audioType) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;`if(audioType.equals("vlc")) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`advancedMusicPlayer = new VlcPlayer();`<br>&nbsp;&nbsp;&nbsp;&nbsp;`} else if(audioType.equals("mp4")) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`advancedMusicPlayer = new Mp4Player();`<br>&nbsp;&nbsp;&nbsp;&nbsp;`}`<br>&nbsp;&nbsp;`}`<br>&nbsp;&nbsp;`public void play(String audioType, String fileName) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;`if(audioType.equals("vlc")) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`advancedMusicPlayer.playVlc(fileName);`<br>&nbsp;&nbsp;&nbsp;&nbsp;`} else if(audioType.equals("mp4")) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`advancedMusicPlayer.playMp4(fileName);`<br>&nbsp;&nbsp;&nbsp;&nbsp;`}`<br>&nbsp;&nbsp;`}`<br>`}` |
| Decorator | Add responsibilities dynamically.<br>• Extends functionality without subclassing<br>• Composition over inheritance<br>• Adds functionality at runtime | `public interface Coffee {`<br>&nbsp;&nbsp;`int getCost();`<br>&nbsp;&nbsp;`String getDescription();`<br>`}`<br>`public class SimpleCoffee implements Coffee {`<br>&nbsp;&nbsp;`public int getCost() { return 5; }`<br>&nbsp;&nbsp;`public String getDescription() { return "Simple coffee"; }`<br>`}`<br>`public class MilkDecorator implements Coffee {`<br>&nbsp;&nbsp;`private Coffee decoratedCoffee;`<br>&nbsp;&nbsp;`public MilkDecorator(Coffee c) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;`this.decoratedCoffee = c;`<br>&nbsp;&nbsp;`}`<br>&nbsp;&nbsp;`public int getCost() {`<br>&nbsp;&nbsp;&nbsp;&nbsp;`return decoratedCoffee.getCost() + 2;`<br>&nbsp;&nbsp;`}`<br>&nbsp;&nbsp;`public String getDescription() {`<br>&nbsp;&nbsp;&nbsp;&nbsp;`return decoratedCoffee.getDescription() + ", milk";`<br>&nbsp;&nbsp;`}`<br>`}` |
| Facade | Simplified interface to complex subsystem.<br>• Hides complexity<br>• Reduces dependencies<br>• Provides unified interface | `// Complex subsystem classes`<br>`class CPU {`<br>&nbsp;&nbsp;`public void freeze() { /*...*/ }`<br>&nbsp;&nbsp;`public void jump(long position) { /*...*/ }`<br>&nbsp;&nbsp;`public void execute() { /*...*/ }`<br>`}`<br>`class Memory {`<br>&nbsp;&nbsp;`public void load(long position, byte[] data) { /*...*/ }`<br>`}`<br>`class HardDrive {`<br>&nbsp;&nbsp;`public byte[] read(long lba, int size) { /*...*/ return null; }`<br>`}`<br><br>`// Facade`<br>`class ComputerFacade {`<br>&nbsp;&nbsp;`private CPU cpu;`<br>&nbsp;&nbsp;`private Memory memory;`<br>&nbsp;&nbsp;`private HardDrive hardDrive;`<br>&nbsp;&nbsp;`public ComputerFacade() {`<br>&nbsp;&nbsp;&nbsp;&nbsp;`this.cpu = new CPU();`<br>&nbsp;&nbsp;&nbsp;&nbsp;`this.memory = new Memory();`<br>&nbsp;&nbsp;&nbsp;&nbsp;`this.hardDrive = new HardDrive();`<br>&nbsp;&nbsp;`}`<br>&nbsp;&nbsp;`public void start() {`<br>&nbsp;&nbsp;&nbsp;&nbsp;`cpu.freeze();`<br>&nbsp;&nbsp;&nbsp;&nbsp;`memory.load(0, hardDrive.read(0, 1024));`<br>&nbsp;&nbsp;&nbsp;&nbsp;`cpu.jump(0);`<br>&nbsp;&nbsp;&nbsp;&nbsp;`cpu.execute();`<br>&nbsp;&nbsp;`}`<br>`}` |
| Composite | Tree structures to represent part-whole hierarchies.<br>• Treats individual objects and compositions uniformly<br>• Simplifies client code<br>• Facilitates recursive operations | `interface Component {`<br>&nbsp;&nbsp;`void operation();`<br>`}`<br>`class Leaf implements Component {`<br>&nbsp;&nbsp;`private String name;`<br>&nbsp;&nbsp;`public Leaf(String name) { this.name = name; }`<br>&nbsp;&nbsp;`public void operation() {`<br>&nbsp;&nbsp;&nbsp;&nbsp;`System.out.println("Leaf " + name + " operation");`<br>&nbsp;&nbsp;`}`<br>`}`<br>`class Composite implements Component {`<br>&nbsp;&nbsp;`private List<Component> children = new ArrayList<>();`<br>&nbsp;&nbsp;`private String name;`<br>&nbsp;&nbsp;`public Composite(String name) { this.name = name; }`<br>&nbsp;&nbsp;`public void add(Component component) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;`children.add(component);`<br>&nbsp;&nbsp;`}`<br>&nbsp;&nbsp;`public void remove(Component component) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;`children.remove(component);`<br>&nbsp;&nbsp;`}`<br>&nbsp;&nbsp;`public void operation() {`<br>&nbsp;&nbsp;&nbsp;&nbsp;`System.out.println("Composite " + name + " operation");`<br>&nbsp;&nbsp;&nbsp;&nbsp;`for (Component component : children) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`component.operation();`<br>&nbsp;&nbsp;&nbsp;&nbsp;`}`<br>&nbsp;&nbsp;`}`<br>`}` |
| Proxy | Control access to original object.<br>• Adds indirection<br>• Supports lazy initialization<br>• Can implement access control | `interface Image {`<br>&nbsp;&nbsp;`void display();`<br>`}`<br>`class RealImage implements Image {`<br>&nbsp;&nbsp;`private String filename;`<br>&nbsp;&nbsp;`public RealImage(String filename) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;`this.filename = filename;`<br>&nbsp;&nbsp;&nbsp;&nbsp;`loadFromDisk();`<br>&nbsp;&nbsp;`}`<br>&nbsp;&nbsp;`private void loadFromDisk() {`<br>&nbsp;&nbsp;&nbsp;&nbsp;`System.out.println("Loading " + filename);`<br>&nbsp;&nbsp;`}`<br>&nbsp;&nbsp;`public void display() {`<br>&nbsp;&nbsp;&nbsp;&nbsp;`System.out.println("Displaying " + filename);`<br>&nbsp;&nbsp;`}`<br>`}`<br>`class ProxyImage implements Image {`<br>&nbsp;&nbsp;`private RealImage realImage;`<br>&nbsp;&nbsp;`private String filename;`<br>&nbsp;&nbsp;`public ProxyImage(String filename) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;`this.filename = filename;`<br>&nbsp;&nbsp;`}`<br>&nbsp;&nbsp;`public void display() {`<br>&nbsp;&nbsp;&nbsp;&nbsp;`if(realImage == null) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`realImage = new RealImage(filename);`<br>&nbsp;&nbsp;&nbsp;&nbsp;`}`<br>&nbsp;&nbsp;&nbsp;&nbsp;`realImage.display();`<br>&nbsp;&nbsp;`}`<br>`}` |

## Behavioral Patterns

| Pattern | Description | Example |
|---------|-------------|---------|
| Observer | One-to-many dependency between objects.<br>• Notifies dependents of state changes<br>• Loose coupling between subjects and observers<br>• Supports broadcast communication | `public interface Observer {`<br>&nbsp;&nbsp;`void update(String message);`<br>`}`<br>`public class Subject {`<br>&nbsp;&nbsp;`private List<Observer> observers = new ArrayList<>();`<br>&nbsp;&nbsp;`public void addObserver(Observer observer) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;`observers.add(observer);`<br>&nbsp;&nbsp;`}`<br>&nbsp;&nbsp;`public void notifyAllObservers(String message) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;`for (Observer observer : observers) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`observer.update(message);`<br>&nbsp;&nbsp;&nbsp;&nbsp;`}`<br>&nbsp;&nbsp;`}`<br>`}` |
| Strategy | Family of algorithms; runtime selection.<br>• Encapsulates interchangeable algorithms<br>• Avoids conditional statements<br>• Runtime behavior selection | `public interface PaymentStrategy {`<br>&nbsp;&nbsp;`void pay(int amount);`<br>`}`<br>`public class CreditCardStrategy implements PaymentStrategy {`<br>&nbsp;&nbsp;`public void pay(int amount) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;`System.out.println("Paid " + amount + " using credit card");`<br>&nbsp;&nbsp;`}`<br>`}`<br>`public class PayPalStrategy implements PaymentStrategy {`<br>&nbsp;&nbsp;`public void pay(int amount) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;`System.out.println("Paid " + amount + " using PayPal");`<br>&nbsp;&nbsp;`}`<br>`}`<br>`// Usage`<br>`PaymentStrategy strategy = new CreditCardStrategy();`<br>`strategy.pay(100);` |
| Command | Encapsulate request as an object.<br>• Decouples sender from receiver<br>• Supports undo operations<br>• Enables queueing of requests | `interface Command {`<br>&nbsp;&nbsp;`void execute();`<br>`}`<br>`class Light {`<br>&nbsp;&nbsp;`public void turnOn() { System.out.println("Light is on"); }`<br>&nbsp;&nbsp;`public void turnOff() { System.out.println("Light is off"); }`<br>`}`<br>`class LightOnCommand implements Command {`<br>&nbsp;&nbsp;`private Light light;`<br>&nbsp;&nbsp;`public LightOnCommand(Light light) { this.light = light; }`<br>&nbsp;&nbsp;`public void execute() { light.turnOn(); }`<br>`}`<br>`class LightOffCommand implements Command {`<br>&nbsp;&nbsp;`private Light light;`<br>&nbsp;&nbsp;`public LightOffCommand(Light light) { this.light = light; }`<br>&nbsp;&nbsp;`public void execute() { light.turnOff(); }`<br>`}`<br>`class RemoteControl {`<br>&nbsp;&nbsp;`private Command command;`<br>&nbsp;&nbsp;`public void setCommand(Command command) { this.command = command; }`<br>&nbsp;&nbsp;`public void pressButton() { command.execute(); }`<br>`}` |
| Template Method | Define skeleton of algorithm, defer certain steps.<br>• Reuses algorithm structure<br>• Enforces consistency between subclasses<br>• Allows controlled extension points | `abstract class Game {`<br>&nbsp;&nbsp;`// Template method`<br>&nbsp;&nbsp;`public final void play() {`<br>&nbsp;&nbsp;&nbsp;&nbsp;`initialize();`<br>&nbsp;&nbsp;&nbsp;&nbsp;`startPlay();`<br>&nbsp;&nbsp;&nbsp;&nbsp;`endPlay();`<br>&nbsp;&nbsp;`}`<br>&nbsp;&nbsp;`// Steps to be implemented by subclasses`<br>&nbsp;&nbsp;`protected abstract void initialize();`<br>&nbsp;&nbsp;`protected abstract void startPlay();`<br>&nbsp;&nbsp;`protected abstract void endPlay();`<br>`}`<br>`class Chess extends Game {`<br>&nbsp;&nbsp;`@Override`<br>&nbsp;&nbsp;`protected void initialize() { System.out.println("Chess initialized"); }`<br>&nbsp;&nbsp;`@Override`<br>&nbsp;&nbsp;`protected void startPlay() { System.out.println("Chess started"); }`<br>&nbsp;&nbsp;`@Override`<br>&nbsp;&nbsp;`protected void endPlay() { System.out.println("Chess ended"); }`<br>`}` |
| State | Alter object behavior when state changes.<br>• Object appears to change class<br>• Encapsulates state-specific behavior<br>• Eliminates large conditionals | `interface State {`<br>&nbsp;&nbsp;`void doAction(Context context);`<br>`}`<br>`class StartState implements State {`<br>&nbsp;&nbsp;`public void doAction(Context context) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;`System.out.println("In start state");`<br>&nbsp;&nbsp;&nbsp;&nbsp;`context.setState(this);`<br>&nbsp;&nbsp;`}`<br>`}`<br>`class StopState implements State {`<br>&nbsp;&nbsp;`public void doAction(Context context) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;`System.out.println("In stop state");`<br>&nbsp;&nbsp;&nbsp;&nbsp;`context.setState(this);`<br>&nbsp;&nbsp;`}`<br>`}`<br>`class Context {`<br>&nbsp;&nbsp;`private State state;`<br>&nbsp;&nbsp;`public void setState(State state) { this.state = state; }`<br>&nbsp;&nbsp;`public State getState() { return state; }`<br>`}` |
| Chain of Responsibility | Pass request along chain of handlers.<br>• Decouples sender and receiver<br>• Dynamic handler chain<br>• Multiple objects can handle request | `abstract class Logger {`<br>&nbsp;&nbsp;`public static int INFO = 1;`<br>&nbsp;&nbsp;`public static int DEBUG = 2;`<br>&nbsp;&nbsp;`public static int ERROR = 3;`<br>&nbsp;&nbsp;`protected int level;`<br>&nbsp;&nbsp;`protected Logger nextLogger;`<br>&nbsp;&nbsp;`public void setNextLogger(Logger nextLogger) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;`this.nextLogger = nextLogger;`<br>&nbsp;&nbsp;`}`<br>&nbsp;&nbsp;`public void logMessage(int level, String message) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;`if(this.level <= level) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`write(message);`<br>&nbsp;&nbsp;&nbsp;&nbsp;`}`<br>&nbsp;&nbsp;&nbsp;&nbsp;`if(nextLogger != null) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`nextLogger.logMessage(level, message);`<br>&nbsp;&nbsp;&nbsp;&nbsp;`}`<br>&nbsp;&nbsp;`}`<br>&nbsp;&nbsp;`abstract protected void write(String message);`<br>`}`<br>`class ConsoleLogger extends Logger {`<br>&nbsp;&nbsp;`public ConsoleLogger(int level) { this.level = level; }`<br>&nbsp;&nbsp;`@Override`<br>&nbsp;&nbsp;`protected void write(String message) {`<br>&nbsp;&nbsp;&nbsp;&nbsp;`System.out.println("Console: " + message);`<br>&nbsp;&nbsp;`}`<br>`}` |