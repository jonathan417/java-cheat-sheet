# Java Networking Cheat Sheet

## Socket Programming

| Concept         | Description                                                                                                    | Example                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| --------------- | -------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Socket          | TCP connection endpoint.<br>• Reliable, connection-oriented vs UDP<br>• Higher overhead<br>• Blocking by default | `// Server socket`<br>`ServerSocket serverSocket = new ServerSocket(8080);`<br>`Socket socket = serverSocket.accept(); // blocks until client connects`<br>`OutputStream out = socket.getOutputStream();`<br>`InputStream in = socket.getInputStream();`<br><br>`// Client socket`<br>`Socket socket = new Socket("localhost", 8080);`<br>`OutputStream out = socket.getOutputStream();`<br>`InputStream in = socket.getInputStream();`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| DatagramSocket  | UDP communication endpoint.<br>• Connectionless vs TCP<br>• Lightweight, faster but unreliable<br>• No guaranteed delivery | `// Sender`<br>`DatagramSocket socket = new DatagramSocket();`<br>`byte[] buffer = "Hello".getBytes();`<br>`InetAddress address = InetAddress.getByName("localhost");`<br>`DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, 9876);`<br>`socket.send(packet);`<br><br>`// Receiver`<br>`DatagramSocket socket = new DatagramSocket(9876);`<br>`byte[] buffer = new byte[1024];`<br>`DatagramPacket packet = new DatagramPacket(buffer, buffer.length);`<br>`socket.receive(packet); // blocks until packet received`<br>`String message = new String(packet.getData(), 0, packet.getLength());`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| MulticastSocket | Group communication over UDP.<br>• One-to-many vs unicast<br>• Efficient for broadcasting<br>• Network support required | `// Join multicast group`<br>`MulticastSocket socket = new MulticastSocket(4446);`<br>`InetAddress group = InetAddress.getByName("230.0.0.1");`<br>`socket.joinGroup(group);`<br><br>`// Send to group`<br>`byte[] msg = "Hello".getBytes();`<br>`DatagramPacket packet = new DatagramPacket(msg, msg.length, group, 4446);`<br>`socket.send(packet);`<br><br>`// Receive from group`<br>`byte[] buf = new byte[1024];`<br>`DatagramPacket recv = new DatagramPacket(buf, buf.length);`<br>`socket.receive(recv);`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Socket Options  | Socket behavior configuration.<br>• Affects performance, reliability, timeouts<br>• Critical for production tuning | `// Set timeout (milliseconds)`<br>`socket.setSoTimeout(5000); // read() will time out after 5 seconds`<br><br>`// Set buffer sizes`<br>`socket.setReceiveBufferSize(8192);`<br>`socket.setSendBufferSize(8192);`<br><br>`// Keep-alive`<br>`socket.setKeepAlive(true);`<br><br>`// Reuse address`<br>`serverSocket.setReuseAddress(true);`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| Non-blocking IO | Scalable IO with selectors.<br>• Higher throughput than blocking IO<br>• More complex<br>• Better for many connections | `// Server with Selector`<br>`Selector selector = Selector.open();`<br>`ServerSocketChannel serverChannel = ServerSocketChannel.open();`<br>`serverChannel.configureBlocking(false);`<br>`serverChannel.socket().bind(new InetSocketAddress(8080));`<br>`serverChannel.register(selector, SelectionKey.OP_ACCEPT);`<br><br>`while (true) {`<br>`    selector.select(); // Blocks until channels are ready`<br>`    Set<SelectionKey> selectedKeys = selector.selectedKeys();`<br>`    Iterator<SelectionKey> iterator = selectedKeys.iterator();`<br>`    while (iterator.hasNext()) {`<br>`        SelectionKey key = iterator.next();`<br>`        if (key.isAcceptable()) {`<br>`            // Accept connection`<br>`            ServerSocketChannel server = (ServerSocketChannel) key.channel();`<br>`            SocketChannel client = server.accept();`<br>`            client.configureBlocking(false);`<br>`            client.register(selector, SelectionKey.OP_READ);`<br>`        } else if (key.isReadable()) {`<br>`            // Read data`<br>`            SocketChannel client = (SocketChannel) key.channel();`<br>`            ByteBuffer buffer = ByteBuffer.allocate(1024);`<br>`            client.read(buffer);`<br>`            buffer.flip();`<br>`            // Process data...`<br>`        }`<br>`        iterator.remove();`<br>`    }`<br>`}` |

## URL and HTTP

| Concept | Description | Example |
|---------|-------------|---------|
| URL | Resource address parser.<br>• Handles protocol, host, path, query parameters<br>• Foundation for HTTP operations | `URL url = new URL("https://api.example.com/users?id=123");`<br>`String protocol = url.getProtocol(); // "https"`<br>`String host = url.getHost(); // "api.example.com"`<br>`String path = url.getPath(); // "/users"`<br>`String query = url.getQuery(); // "id=123"` |
| URLConnection | Basic HTTP client.<br>• Simple but limited vs HttpURLConnection<br>• No HTTP-specific methods<br>• Useful for basic operations | `URL url = new URL("https://api.example.com/data.json");`<br>`URLConnection conn = url.openConnection();`<br>`conn.setRequestProperty("Accept", "application/json");`<br>`conn.setConnectTimeout(5000);`<br>`conn.setReadTimeout(5000);`<br>`conn.connect();`<br><br>`// Reading response`<br>`try (InputStream in = conn.getInputStream();`<br>`     BufferedReader reader = new BufferedReader(new InputStreamReader(in))) {`<br>`    String line;`<br>`    while ((line = reader.readLine()) != null) {`<br>`        System.out.println(line);`<br>`    }`<br>`}` |
| HttpURLConnection | HTTP-specific client.<br>• More features than URLConnection<br>• Clunky API vs Java 11 HttpClient<br>• Widely compatible | `URL url = new URL("https://api.example.com/users");`<br>`HttpURLConnection conn = (HttpURLConnection) url.openConnection();`<br>`conn.setRequestMethod("POST");`<br>`conn.setDoOutput(true);`<br>`conn.setRequestProperty("Content-Type", "application/json");`<br><br>`// Write request body`<br>`try (OutputStream os = conn.getOutputStream();`<br>`     OutputStreamWriter writer = new OutputStreamWriter(os)) {`<br>`    writer.write("{\"name\":\"John\",\"age\":30}");`<br>`}`<br><br>`// Get response code`<br>`int responseCode = conn.getResponseCode();`<br>`if (responseCode == HttpURLConnection.HTTP_OK) {`<br>`    // Read response`<br>`    try (BufferedReader reader = new BufferedReader(`<br>`         new InputStreamReader(conn.getInputStream()))) {`<br>`        String line;`<br>`        while ((line = reader.readLine()) != null) {`<br>`            System.out.println(line);`<br>`        }`<br>`    }`<br>`} else {`<br>`    // Handle error`<br>`    try (BufferedReader reader = new BufferedReader(`<br>`         new InputStreamReader(conn.getErrorStream()))) {`<br>`        // Read error response`<br>`    }`<br>`}` |
| Java 11 HttpClient | Modern HTTP API.<br>• Supports HTTP/2, WebSockets vs older APIs<br>• Fluent API; async capabilities<br>• Better performance | `HttpClient client = HttpClient.newBuilder()`<br>`    .version(HttpClient.Version.HTTP_2)`<br>`    .connectTimeout(Duration.ofSeconds(5))`<br>`    .followRedirects(HttpClient.Redirect.NORMAL)`<br>`    .build();`<br><br>`// GET request`<br>`HttpRequest request = HttpRequest.newBuilder()`<br>`    .uri(URI.create("https://api.example.com/users"))`<br>`    .header("Accept", "application/json")`<br>`    .GET()`<br>`    .build();`<br><br>`HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());`<br>`int statusCode = response.statusCode();`<br>`String body = response.body();`<br><br>`// POST request`<br>`HttpRequest postRequest = HttpRequest.newBuilder()`<br>`    .uri(URI.create("https://api.example.com/users"))`<br>`    .header("Content-Type", "application/json")`<br>`    .POST(HttpRequest.BodyPublishers.ofString("{\"name\":\"John\",\"age\":30}"))`<br>`    .build();`<br><br>`client.send(postRequest, HttpResponse.BodyHandlers.ofString());`<br><br>`// Asynchronous request`<br>`CompletableFuture<HttpResponse<String>> future = client.sendAsync(`<br>`    request, HttpResponse.BodyHandlers.ofString());`<br>`future.thenApply(HttpResponse::body)`<br>`      .thenAccept(System.out::println);` |
| Cookies | HTTP state management.<br>• Session persistence vs stateless requests<br>• Security considerations<br>• Automated handling | `// Using CookieManager with HttpURLConnection`<br>`CookieManager cookieManager = new CookieManager();`<br>`cookieManager.setCookiePolicy(CookiePolicy.ACCEPT_ALL);`<br>`CookieHandler.setDefault(cookieManager);`<br><br>`URL url = new URL("https://example.com/login");`<br>`HttpURLConnection conn = (HttpURLConnection) url.openConnection();`<br>`// ... perform request ...`<br><br>`// Get cookies after request`<br>`CookieStore cookieStore = cookieManager.getCookieStore();`<br>`List<HttpCookie> cookies = cookieStore.getCookies();`<br><br>`// Using HttpClient (Java 11+)`<br>`HttpClient client = HttpClient.newBuilder()`<br>`    .cookieHandler(new CookieManager())`<br>`    .build();` |

## Web Services

| Concept | Description | Example |
|---------|-------------|---------|
| REST Client | Lightweight HTTP-based API consumption.<br>• Simpler than SOAP<br>• Less flexible than GraphQL | `// Using RestTemplate (Spring)`<br>`RestTemplate restTemplate = new RestTemplate();`<br><br>`// GET request`<br>`User user = restTemplate.getForObject(`<br>`    "https://api.example.com/users/{id}",`<br>`    User.class, 123);`<br><br>`// POST request`<br>`User newUser = new User("John", "john@example.com");`<br>`User created = restTemplate.postForObject(`<br>`    "https://api.example.com/users",`<br>`    newUser, User.class);`<br><br>`// PUT request`<br>`newUser.setName("John Smith");`<br>`restTemplate.put(`<br>`    "https://api.example.com/users/{id}",`<br>`    newUser, newUser.getId());`<br><br>`// DELETE request`<br>`restTemplate.delete(`<br>`    "https://api.example.com/users/{id}",`<br>`    123);` |
| REST Server | HTTP-based APIs with Spring.<br>• Faster development than JAX-RS<br>• Less portable across containers | `// Controller in Spring Boot`<br>`@RestController`<br>`@RequestMapping("/api/users")`<br>`public class UserController {`<br><br>`    @Autowired`<br>`    private UserService userService;`<br><br>`    @GetMapping("/{id}")`<br>`    public ResponseEntity<User> getUser(@PathVariable Long id) {`<br>`        User user = userService.findById(id);`<br>`        return ResponseEntity.ok(user);`<br>`    }`<br><br>`    @PostMapping`<br>`    public ResponseEntity<User> createUser(@RequestBody User user) {`<br>`        User savedUser = userService.save(user);`<br>`        return ResponseEntity.status(HttpStatus.CREATED).body(savedUser);`<br>`    }`<br><br>`    @PutMapping("/{id}")`<br>`    public ResponseEntity<User> updateUser(`<br>`            @PathVariable Long id, @RequestBody User user) {`<br>`        user.setId(id);`<br>`        User updatedUser = userService.update(user);`<br>`        return ResponseEntity.ok(updatedUser);`<br>`    }`<br><br>`    @DeleteMapping("/{id}")`<br>`    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {`<br>`        userService.deleteById(id);`<br>`        return ResponseEntity.noContent().build();`<br>`    }`<br>`}` |
| JAX-RS | Standardized REST framework.<br>• More portable than Spring REST<br>• More verbose<br>• Better for cross-container enterprise apps | `// Client (Jersey implementation)`<br>`Client client = ClientBuilder.newClient();`<br>`WebTarget target = client.target("https://api.example.com/users");`<br><br>`// GET request`<br>`Response response = target.path("123")`<br>`    .request(MediaType.APPLICATION_JSON)`<br>`    .get();`<br>`User user = response.readEntity(User.class);`<br><br>`// POST request`<br>`User newUser = new User("John", "john@example.com");`<br>`Response postResponse = target`<br>`    .request(MediaType.APPLICATION_JSON)`<br>`    .post(Entity.entity(newUser, MediaType.APPLICATION_JSON));`<br><br>`// Server (RESTful service)`<br>`@Path("/users")`<br>`public class UserResource {`<br>`    @GET`<br>`    @Path("/{id}")`<br>`    @Produces(MediaType.APPLICATION_JSON)`<br>`    public User getUser(@PathParam("id") long id) {`<br>`        // Get and return user`<br>`    }`<br><br>`    @POST`<br>`    @Consumes(MediaType.APPLICATION_JSON)`<br>`    @Produces(MediaType.APPLICATION_JSON)`<br>`    public Response createUser(User user) {`<br>`        // Create user and return response`<br>`        return Response.status(Status.CREATED)`<br>`            .entity(user).build();`<br>`    }`<br>`}` |
| GraphQL | Query language for precise data retrieval.<br>• Single endpoint vs REST's multiple<br>• Reduces over/under-fetching<br>• Steeper learning curve | `// Using GraphQL Java`<br><br>`// Define schema`<br>`String schema = "type Query { user(id: ID): User }" +`<br>`              "type User { id: ID, name: String, email: String }" +`<br>`              "type Mutation { createUser(name: String, email: String): User }";`<br><br>`// Create GraphQL instance`<br>`SchemaParser schemaParser = new SchemaParser();`<br>`TypeDefinitionRegistry typeRegistry = schemaParser.parse(schema);`<br>`RuntimeWiring wiring = RuntimeWiring.newRuntimeWiring()`<br>`    .type("Query", builder -> builder.dataFetcher("user", userFetcher))`<br>`    .type("Mutation", builder -> builder.dataFetcher("createUser", createUserFetcher))`<br>`    .build();`<br><br>`SchemaGenerator schemaGenerator = new SchemaGenerator();`<br>`GraphQLSchema graphQLSchema = schemaGenerator.makeExecutableSchema(typeRegistry, wiring);`<br>`GraphQL graphQL = GraphQL.newGraphQL(graphQLSchema).build();`<br><br>`// Execute query`<br>`String query = "{ user(id: \"123\") { id name email } }";`<br>`ExecutionResult result = graphQL.execute(query);`<br>`Map<String, Object> data = result.getData();`<br><br>`// Client with Spring GraphQL`<br>`String query = "query { user(id: 123) { id name email } }";`<br>`GraphQLResponse response = graphQLClient.query(query).execute();`<br>`User user = response.get("user", User.class);` |
| WebSocket | Full-duplex communication channel.<br>• Real-time, persistent connection vs HTTP request/response<br>• Higher overhead than SSE | `// Client (Java API for WebSocket)`<br>`@ClientEndpoint`<br>`public class WebSocketClient {`<br>`    private Session session;`<br>`    `<br>`    @OnOpen`<br>`    public void onOpen(Session session) {`<br>`        this.session = session;`<br>`        System.out.println("Connected to server");`<br>`    }`<br>`    `<br>`    @OnMessage`<br>`    public void onMessage(String message) {`<br>`        System.out.println("Received: " + message);`<br>`    }`<br>`    `<br>`    public void sendMessage(String message) {`<br>`        session.getAsyncRemote().sendText(message);`<br>`    }`<br>`}`<br><br>`// Connect to WebSocket server`<br>`WebSocketContainer container = ContainerProvider.getWebSocketContainer();`<br>`WebSocketClient client = new WebSocketClient();`<br>`container.connectToServer(client, new URI("ws://example.com/socket"));`<br><br>`// Server endpoint`<br>`@ServerEndpoint("/socket")`<br>`public class WebSocketServer {`<br>`    @OnOpen`<br>`    public void onOpen(Session session) {`<br>`        System.out.println("Client connected");`<br>`    }`<br>`    `<br>`    @OnMessage`<br>`    public void onMessage(String message, Session session) throws IOException {`<br>`        System.out.println("Received: " + message);`<br>`        session.getBasicRemote().sendText("Echo: " + message);`<br>`    }`<br>`}` |
| WebSocket (Spring) | Higher-level WebSocket abstraction.<br>• Adds STOMP messaging<br>• Easier than raw WebSockets for pub/sub patterns | `// Spring WebSocket configuration`<br>`@Configuration`<br>`@EnableWebSocketMessageBroker`<br>`public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {`<br><br>`    @Override`<br>`    public void configureMessageBroker(MessageBrokerRegistry config) {`<br>`        config.enableSimpleBroker("/topic");`<br>`        config.setApplicationDestinationPrefixes("/app");`<br>`    }`<br><br>`    @Override`<br>`    public void registerStompEndpoints(StompEndpointRegistry registry) {`<br>`        registry.addEndpoint("/ws").withSockJS();`<br>`    }`<br>`}`<br><br>`// Controller`<br>`@Controller`<br>`public class ChatController {`<br><br>`    @MessageMapping("/chat.send")`<br>`    @SendTo("/topic/messages")`<br>`    public ChatMessage send(ChatMessage message) {`<br>`        return message;`<br>`    }`<br>`}`<br><br>`// JavaScript client`<br>`var socket = new SockJS('/ws');`<br>`var stompClient = Stomp.over(socket);`<br>`stompClient.connect({}, function() {`<br>`    stompClient.subscribe('/topic/messages', function(message) {`<br>`        // Handle incoming message`<br>`    });`<br><br>`    stompClient.send("/app/chat.send", {}, JSON.stringify({`<br>`        sender: "John",`<br>`        content: "Hello, world!"`<br>`    }));`<br>`});` |
| SOAP | XML-based enterprise messaging.<br>• More rigid than REST<br>• Better built-in security/transactions<br>• Heavier overhead | `// Create SOAP client (JAX-WS)`<br>`URL wsdlURL = new URL("http://example.com/service?wsdl");`<br>`QName qname = new QName("http://service.example.com/", "ServiceName");`<br>`Service service = Service.create(wsdlURL, qname);`<br>`ServiceInterface port = service.getPort(ServiceInterface.class);`<br><br>`// Call service method`<br>`String result = port.someMethod("parameter");`<br><br>`// SOAP service endpoint (JAX-WS)`<br>`@WebService(serviceName = "ServiceName")`<br>`public class ServiceImpl implements ServiceInterface {`<br><br>`    @WebMethod`<br>`    public String someMethod(@WebParam(name = "param") String param) {`<br>`        return "Processed: " + param;`<br>`    }`<br>`}` |
| gRPC | High-performance RPC with HTTP/2.<br>• Faster than REST/SOAP<br>• Compact binary format<br>• Requires code generation<br>• Ideal for microservices | `// Proto definition`<br>`syntax = "proto3";`<br>`service UserService {`<br>`  rpc GetUser (GetUserRequest) returns (User) {}`<br>`  rpc CreateUser (CreateUserRequest) returns (User) {}`<br>`}`<br>`message GetUserRequest {`<br>`  int64 user_id = 1;`<br>`}`<br>`message CreateUserRequest {`<br>`  string name = 1;`<br>`  string email = 2;`<br>`}`<br>`message User {`<br>`  int64 id = 1;`<br>`  string name = 2;`<br>`  string email = 3;`<br>`}`<br><br>`// Server implementation`<br>`public class UserServiceImpl extends UserServiceGrpc.UserServiceImplBase {`<br>`  @Override`<br>`  public void getUser(GetUserRequest request,`<br>`                   StreamObserver<User> responseObserver) {`<br>`    User user = User.newBuilder()`<br>`        .setId(request.getUserId())`<br>`        .setName("John Doe")`<br>`        .setEmail("john@example.com")`<br>`        .build();`<br>`    responseObserver.onNext(user);`<br>`    responseObserver.onCompleted();`<br>`  }`<br>`}`<br><br>`// Start gRPC server`<br>`Server server = ServerBuilder.forPort(8080)`<br>`    .addService(new UserServiceImpl())`<br>`    .build();`<br>`server.start();`<br><br>`// Client`<br>`ManagedChannel channel = ManagedChannelBuilder.forAddress("localhost", 8080)`<br>`    .usePlaintext()`<br>`    .build();`<br>`UserServiceGrpc.UserServiceBlockingStub stub = UserServiceGrpc.newBlockingStub(channel);`<br><br>`GetUserRequest request = GetUserRequest.newBuilder().setUserId(123).build();`<br>`User user = stub.getUser(request);`<br>`System.out.println("User: " + user.getName());` |

## Network Protocols

| Protocol | Description | Example |
|----------|-------------|---------|
| FTP | File Transfer Protocol.<br>• Separate control/data channels vs HTTP<br>• Good for large files<br>• Less secure than SFTP | `// Using Apache Commons Net`<br>`FTPClient client = new FTPClient();`<br>`client.connect("ftp.example.com");`<br>`boolean success = client.login("username", "password");`<br><br>`// Upload file`<br>`try (FileInputStream fis = new FileInputStream("local-file.txt")) {`<br>`    client.storeFile("remote-file.txt", fis);`<br>`}`<br><br>`// Download file`<br>`try (FileOutputStream fos = new FileOutputStream("local-file.txt")) {`<br>`    client.retrieveFile("remote-file.txt", fos);`<br>`}`<br><br>`client.logout();`<br>`client.disconnect();` |
| SMTP | Simple Mail Transfer Protocol.<br>• Email sending standard<br>• Requires authentication<br>• Often paired with IMAP/POP3 | `// Send email using JavaMail`<br>`Properties props = new Properties();`<br>`props.put("mail.smtp.host", "smtp.example.com");`<br>`props.put("mail.smtp.port", "587");`<br>`props.put("mail.smtp.auth", "true");`<br>`props.put("mail.smtp.starttls.enable", "true");`<br><br>`Session session = Session.getInstance(props, new Authenticator() {`<br>`    protected PasswordAuthentication getPasswordAuthentication() {`<br>`        return new PasswordAuthentication("username", "password");`<br>`    }`<br>`});`<br><br>`Message message = new MimeMessage(session);`<br>`message.setFrom(new InternetAddress("from@example.com"));`<br>`message.setRecipients(Message.RecipientType.TO, `<br>`    InternetAddress.parse("to@example.com"));`<br>`message.setSubject("Test Email");`<br>`message.setText("Hello, this is a test email.");`<br><br>`Transport.send(message);` |
| IMAP | Internet Message Access Protocol.<br>• Server-stored emails vs. POP3's download-and-delete<br>• Better for multiple devices<br>• More complex | `// Using JavaMail`<br>`Properties props = new Properties();`<br>`props.put("mail.store.protocol", "imaps");`<br><br>`Session session = Session.getDefaultInstance(props);`<br>`Store store = session.getStore("imaps");`<br>`store.connect("imap.example.com", "username", "password");`<br><br>`// Access inbox`<br>`Folder inbox = store.getFolder("INBOX");`<br>`inbox.open(Folder.READ_ONLY);`<br><br>`// Get messages`<br>`Message[] messages = inbox.getMessages();`<br>`for (Message message : messages) {`<br>`    System.out.println("Subject: " + message.getSubject());`<br>`    System.out.println("From: " + message.getFrom()[0]);`<br>`}`<br><br>`inbox.close(false);`<br>`store.close();` |
| DNS | Domain Name System.<br>• Hostname-to-IP resolution<br>• Hierarchical distributed database<br>• Critical internet infrastructure | `// Lookup IP address`<br>`InetAddress address = InetAddress.getByName("www.example.com");`<br>`String ip = address.getHostAddress();`<br><br>`// Reverse lookup`<br>`InetAddress addr = InetAddress.getByAddress(new byte[]{8, 8, 8, 8});`<br>`String hostname = addr.getHostName();`<br><br>`// Using dnsjava library`<br>`Record[] records = new Lookup("example.com", Type.MX).run();`<br>`for (Record record : records) {`<br>`    MXRecord mx = (MXRecord) record;`<br>`    System.out.println("Mail server: " + mx.getTarget());`<br>`}` |
| LDAP | Lightweight Directory Access Protocol.<br>• Hierarchical directory access<br>• Efficient reads vs writes<br>• Common for authentication/authorization | `// JNDI with LDAP`<br>`Hashtable<String, String> env = new Hashtable<>();`<br>`env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");`<br>`env.put(Context.PROVIDER_URL, "ldap://ldap.example.com:389");`<br>`env.put(Context.SECURITY_AUTHENTICATION, "simple");`<br>`env.put(Context.SECURITY_PRINCIPAL, "cn=admin,dc=example,dc=com");`<br>`env.put(Context.SECURITY_CREDENTIALS, "password");`<br><br>`DirContext ctx = new InitialDirContext(env);`<br><br>`// Search for users`<br>`SearchControls controls = new SearchControls();`<br>`controls.setSearchScope(SearchControls.SUBTREE_SCOPE);`<br>`NamingEnumeration<SearchResult> results = ctx.search(`<br>`    "ou=users,dc=example,dc=com",`<br>`    "(objectClass=person)",`<br>`    controls);`<br><br>`while (results.hasMore()) {`<br>`    SearchResult result = results.next();`<br>`    Attributes attrs = result.getAttributes();`<br>`    System.out.println("Name: " + attrs.get("cn").get());`<br>`    System.out.println("Email: " + attrs.get("mail").get());`<br>`}`<br><br>`ctx.close();` |

## Network Security

| Concept | Description | Example |
|---------|-------------|---------|
| SSL/TLS | Secure communication layer.<br>• Encrypts data in transit<br>• TLS 1.3 vs older versions<br>• Certificate-based trust | `// SSL client socket`<br>`SSLSocketFactory factory = (SSLSocketFactory) SSLSocketFactory.getDefault();`<br>`SSLSocket socket = (SSLSocket) factory.createSocket("example.com", 443);`<br><br>`// Specify TLS protocol versions`<br>`socket.setEnabledProtocols(new String[] {"TLSv1.2", "TLSv1.3"});`<br><br>`// Connect and use socket`<br>`OutputStream out = socket.getOutputStream();`<br>`InputStream in = socket.getInputStream();`<br><br>`// SSL server socket`<br>`// First set up KeyStore with certificate`<br>`KeyStore ks = KeyStore.getInstance("JKS");`<br>`ks.load(new FileInputStream("keystore.jks"), "password".toCharArray());`<br><br>`KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());`<br>`kmf.init(ks, "password".toCharArray());`<br><br>`SSLContext sslContext = SSLContext.getInstance("TLS");`<br>`sslContext.init(kmf.getKeyManagers(), null, null);`<br><br>`SSLServerSocketFactory sslServerFactory = sslContext.getServerSocketFactory();`<br>`SSLServerSocket serverSocket = (SSLServerSocket) sslServerFactory.createServerSocket(8443);` |
| Client Authentication | Mutual TLS authentication.<br>• Two-way trust vs server-only authentication<br>• Stronger security<br>• More complex setup | `// Configure TrustManager with client certificates`<br>`KeyStore ts = KeyStore.getInstance("JKS");`<br>`ts.load(new FileInputStream("truststore.jks"), "password".toCharArray());`<br><br>`TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());`<br>`tmf.init(ts);`<br><br>`SSLContext sslContext = SSLContext.getInstance("TLS");`<br>`sslContext.init(null, tmf.getTrustManagers(), null);`<br><br>`// Create HTTPS server requiring client auth`<br>`HttpsServer server = HttpsServer.create(new InetSocketAddress(8443), 0);`<br>`server.setHttpsConfigurator(new HttpsConfigurator(sslContext) {`<br>`    public void configure(HttpsParameters params) {`<br>`        params.setNeedClientAuth(true);`<br>`    }`<br>`});` |
| Proxies | HTTP/HTTPS intermediaries.<br>• Add security layers<br>• Enable caching/monitoring<br>• May impact performance | `// Set system proxy`<br>`System.setProperty("http.proxyHost", "proxy.example.com");`<br>`System.setProperty("http.proxyPort", "8080");`<br>`System.setProperty("https.proxyHost", "proxy.example.com");`<br>`System.setProperty("https.proxyPort", "8080");`<br><br>`// Proxy authentication`<br>`Authenticator.setDefault(new Authenticator() {`<br>`    @Override`<br>`    protected PasswordAuthentication getPasswordAuthentication() {`<br>`        return new PasswordAuthentication("username", "password".toCharArray());`<br>`    }`<br>`});`<br><br>`// Using Proxy class directly`<br>`Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress("proxy.example.com", 8080));`<br>`URL url = new URL("http://example.com");`<br>`HttpURLConnection conn = (HttpURLConnection) url.openConnection(proxy);`<br><br>`// Java 11+ HttpClient with proxy`<br>`HttpClient client = HttpClient.newBuilder()`<br>`    .proxy(ProxySelector.of(new InetSocketAddress("proxy.example.com", 8080)))`<br>`    .build();` |
| Network Firewall | Filtering traffic at network level.<br>• Blocks unwanted connections<br>• Java detects but doesn't control<br>• Affects application design | `// Java doesn't directly control network firewalls,`<br>`// but can detect firewall settings and adjust behavior`<br>`Socket socket = new Socket();`<br>`try {`<br>`    socket.connect(new InetSocketAddress("example.com", 80), 5000); // 5 second timeout`<br>`    // Connection succeeded`<br>`} catch (SocketTimeoutException e) {`<br>`    // Possible firewall blocking`<br>`    System.out.println("Connection timed out, possible firewall block");`<br>`} catch (ConnectException e) {`<br>`    // Connection refused`<br>`    System.out.println("Connection refused, port may be blocked by firewall");`<br>`}` |
| Certificate Pinning | Validate server certificate.<br>• Prevents MITM attacks vs standard validation<br>• Limits flexibility<br>• Improves security | `// OkHttp library example`<br>`CertificatePinner pinner = new CertificatePinner.Builder()`<br>`    .add("example.com", "sha256/XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX=")`<br>`    .build();`<br><br>`OkHttpClient client = new OkHttpClient.Builder()`<br>`    .certificatePinner(pinner)`<br>`    .build();`<br><br>`// DIY approach with HttpsURLConnection`<br>`HttpsURLConnection conn = (HttpsURLConnection) new URL("https://example.com").openConnection();`<br>`conn.setSSLSocketFactory(new PinningSSLSocketFactory(expectedCertificate));` |

## Network Diagnostics

| Tool | Description | Example |
|------|-------------|---------|
| InetAddress | IP address and hostname utilities.<br>• Provides name resolution<br>• Reachability checks<br>• Simpler than NetworkInterface for basic tasks | `// Check if host is reachable`<br>`// ...existing code...` |
| NetworkInterface | Local network interface information.<br>• More detailed than InetAddress<br>• Hardware-level access<br>• Useful for multi-homed hosts | `// List all network interfaces`<br>`// ...existing code...` |
| SocketOptions | Analyze socket parameters.<br>• Fine-tune performance vs defaults<br>• Affects throughput/latency<br>• Critical for high-traffic systems | `// Get socket information`<br>`// ...existing code...` |
| Ping | Check host availability.<br>• Simple connectivity test vs traceroute<br>• Quick test for network presence | `// Manual implementation`<br>`// ...existing code...` |
| Traceroute | Trace network path to host.<br>• More detailed than ping<br>• Identifies bottlenecks<br>• Helps diagnose routing issues | `// Using ProcessBuilder (system traceroute command)`<br>`// ...existing code...` |
| HTTP Diagnostics | Analyze HTTP requests and responses.<br>• Identifies bottlenecks vs network issues<br>• Measures response times<br>• Troubleshoots API integration | `// Using HttpURLConnection`<br>`// ...existing code...` |