# Java Encryption and Security Cheat Sheet

## Cryptography Basics

| Concept | Description | Example |
|---------|-------------|---------|
| Symmetric Encryption | Same key for encryption and decryption.<br>• Faster than asymmetric<br>• Key distribution is challenging<br>• Good for large data volumes | `// AES encryption with Java`<br>`SecretKey key = KeyGenerator.getInstance("AES").generateKey();`<br>`Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");`<br>`cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(iv));`<br>`byte[] encrypted = cipher.doFinal("Secret data".getBytes());` |
| Asymmetric Encryption | Public key for encryption, private key for decryption.<br>• Better key management<br>• Slower than symmetric<br>• Good for secure key exchange | `// RSA encryption with Java`<br>`KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");`<br>`keyGen.initialize(2048);`<br>`KeyPair keyPair = keyGen.generateKeyPair();`<br>`PublicKey publicKey = keyPair.getPublic();`<br>`PrivateKey privateKey = keyPair.getPrivate();`<br><br>`// Encrypt with public key`<br>`Cipher cipher = Cipher.getInstance("RSA");`<br>`cipher.init(Cipher.ENCRYPT_MODE, publicKey);`<br>`byte[] encrypted = cipher.doFinal("Secret data".getBytes());`<br><br>`// Decrypt with private key`<br>`cipher.init(Cipher.DECRYPT_MODE, privateKey);`<br>`byte[] decrypted = cipher.doFinal(encrypted);` |
| Hash Functions | One-way function.<br>• Can't retrieve original data<br>• Used for integrity checks<br>• Fixed output length regardless of input | `// SHA-256 hashing`<br>`MessageDigest digest = MessageDigest.getInstance("SHA-256");`<br>`byte[] hash = digest.digest("Password123".getBytes());`<br>`String hexHash = DatatypeConverter.printHexBinary(hash);` |
| MAC (Message Authentication Code) | Ensures integrity and authenticity.<br>• Requires shared key<br>• Combines hash function with a key<br>• Detects message tampering | `// HMAC with SHA-256`<br>`SecretKey key = new SecretKeySpec("secret".getBytes(), "HmacSHA256");`<br>`Mac mac = Mac.getInstance("HmacSHA256");`<br>`mac.init(key);`<br>`byte[] macBytes = mac.doFinal("Message to authenticate".getBytes());` |
| Digital Signatures | Ensures non-repudiation, integrity, and authenticity.<br>• Uses asymmetric keys<br>• Sign with private key, verify with public key<br>• Provides proof of origin | `// Sign with private key`<br>`Signature signature = Signature.getInstance("SHA256withRSA");`<br>`signature.initSign(privateKey);`<br>`signature.update("Document to sign".getBytes());`<br>`byte[] signatureBytes = signature.sign();`<br><br>`// Verify with public key`<br>`signature.initVerify(publicKey);`<br>`signature.update("Document to sign".getBytes());`<br>`boolean isValid = signature.verify(signatureBytes);` |

## SSL/TLS and HTTPS

| Concept | Description | Example |
|---------|-------------|---------|
| SSL/TLS | Secure communication protocols.<br>• TLS is newer version of SSL<br>• Provides encryption, authentication, and integrity<br>• Uses certificate-based trust model | `// Creating SSLContext`<br>`SSLContext sslContext = SSLContext.getInstance("TLS");`<br>`sslContext.init(keyManagers, trustManagers, null);`<br>`SSLSocketFactory factory = sslContext.getSocketFactory();` |
| Certificates | Digital documents binding public key to an identity.<br>• Signed by Certificate Authority (CA)<br>• Contains subject info, public key, and CA signature<br>• Forms basis of trust in HTTPS | `// Loading a certificate`<br>`CertificateFactory cf = CertificateFactory.getInstance("X.509");`<br>`FileInputStream fis = new FileInputStream("certificate.crt");`<br>`X509Certificate cert = (X509Certificate) cf.generateCertificate(fis);`<br>`PublicKey publicKey = cert.getPublicKey();` |
| HTTPS Client | Making secure HTTP requests.<br>• Validates server certificates<br>• Encrypts data in transit<br>• Prevents man-in-the-middle attacks | `// HttpsURLConnection`<br>`URL url = new URL("https://api.example.com/data");`<br>`HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();`<br>`conn.setSSLSocketFactory(sslContext.getSocketFactory());`<br>`InputStream is = conn.getInputStream();`<br><br>`// Java 11+ HttpClient`<br>`HttpClient client = HttpClient.newBuilder()`<br>`    .sslContext(sslContext)`<br>`    .build();`<br>`HttpRequest request = HttpRequest.newBuilder()`<br>`    .uri(URI.create("https://api.example.com/data"))`<br>`    .GET()`<br>`    .build();`<br>`HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());` |
| HTTPS Server | Setting up a secure server.<br>• Requires server certificate and private key<br>• Configurable cipher suites and protocols<br>• Client authentication options | `// Spring Boot HTTPS Configuration`<br>`# application.properties`<br>`server.port=8443`<br>`server.ssl.key-store=classpath:keystore.p12`<br>`server.ssl.key-store-password=password`<br>`server.ssl.key-store-type=PKCS12`<br>`server.ssl.key-alias=tomcat`<br><br>`// Tomcat HTTPS Configuration`<br>`Connector connector = new Connector("org.apache.coyote.http11.Http11NioProtocol");`<br>`connector.setScheme("https");`<br>`connector.setPort(8443);`<br>`connector.setSecure(true);`<br>`connector.setProperty("keyAlias", "tomcat");`<br>`connector.setProperty("keystorePass", "password");`<br>`connector.setProperty("keystoreFile", "/path/to/keystore.p12");`<br>`connector.setProperty("clientAuth", "false");`<br>`connector.setProperty("sslProtocol", "TLS");` |
| Certificate Generation | Creating SSL certificates for testing or production.<br>• Self-signed for development<br>• CA-signed for production<br>• Managed through keytool utility | `# Generate keystore with keytool`<br>`keytool -genkeypair -alias tomcat -keyalg RSA -keysize 2048 \`<br>`  -storetype PKCS12 -keystore keystore.p12 -validity 3650 \`<br>`  -storepass password`<br><br>`# Generate CSR (Certificate Signing Request) for CA`<br>`keytool -certreq -alias tomcat -keystore keystore.p12 \`<br>`  -file certreq.csr -storepass password`<br><br>`# Import signed certificate from CA`<br>`keytool -importcert -alias tomcat -file signed_cert.crt \`<br>`  -keystore keystore.p12 -storepass password`<br><br>`# Trust a CA certificate`<br>`keytool -importcert -alias root -file ca_cert.crt \`<br>`  -keystore truststore.jks -storepass password` |

## Java Security Features

| Concept | Description | Example |
|---------|-------------|---------|
| Java KeyStore | Repository for keys and certificates.<br>• Secure storage for cryptographic keys<br>• Protection with password<br>• Different formats (JKS, PKCS12) | `// Load KeyStore`<br>`KeyStore keyStore = KeyStore.getInstance("PKCS12");`<br>`keyStore.load(new FileInputStream("keystore.p12"), "password".toCharArray());`<br><br>`// Get private key`<br>`PrivateKey privateKey = (PrivateKey) keyStore.getKey("alias", "password".toCharArray());`<br><br>`// Get certificate`<br>`Certificate cert = keyStore.getCertificate("alias");`<br>`PublicKey publicKey = cert.getPublicKey();` |
| SecureRandom | Cryptographically strong random number generator.<br>• Non-predictable randomness<br>• Used for initialization vectors, nonces, salts<br>• Platform-specific implementations | `// Generate random bytes`<br>`SecureRandom random = SecureRandom.getInstanceStrong();`<br>`byte[] randomBytes = new byte[32];`<br>`random.nextBytes(randomBytes);` |
| Password Hashing | Secure storage of passwords.<br>• Uses salting to prevent rainbow tables<br>• Slow algorithms preferred (PBKDF2, BCrypt)<br>• Iteration count increases computation cost | `// Using PBKDF2 (recommended)`<br>`String password = "userPassword";`<br>`byte[] salt = new byte[16];`<br>`SecureRandom sr = SecureRandom.getInstance("SHA1PRNG");`<br>`sr.nextBytes(salt);`<br>`int iterations = 10000;`<br>`int keyLength = 256;`<br><br>`PBEKeySpec spec = new PBEKeySpec(password.toCharArray(), salt, iterations, keyLength);`<br>`SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");`<br>`byte[] hash = factory.generateSecret(spec).getEncoded();`<br><br>`// Store salt and hash in database` |
| Java Security Manager | Define access control policy for applications.<br>• Sandbox for untrusted code<br>• Fine-grained permission system<br>• Policy-based access control | `// Launch Java with security manager`<br>`java -Djava.security.manager -Djava.security.policy=app.policy MyApp`<br><br>`// Example policy file (app.policy)`<br>`grant codeBase "file:/path/to/app/" {`<br>`    permission java.io.FilePermission "/tmp/*", "read,write";`<br>`    permission java.net.SocketPermission "localhost:8000", "connect";`<br>`};` |
| JAAS | Java Authentication and Authorization Service.<br>• Pluggable authentication modules<br>• Subject-based authorization<br>• Declarative security model | `// Login configuration`<br>`LoginContext lc = new LoginContext("MyApp", new CallbackHandler() {`<br>`    public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException {`<br>`        for (Callback callback : callbacks) {`<br>`            if (callback instanceof NameCallback) {`<br>`                ((NameCallback) callback).setName("username");`<br>`            } else if (callback instanceof PasswordCallback) {`<br>`                ((PasswordCallback) callback).setPassword("password".toCharArray());`<br>`            }`<br>`        }`<br>`    }`<br>`});`<br>`lc.login();`<br>`Subject subject = lc.getSubject();` |

## Common Encryption Algorithms

| Algorithm | Type | Key Size | Usage | Example |
|-----------|------|----------|-------|---------|
| AES | Symmetric<br>• Fast block cipher<br>• Industry standard<br>• Multiple modes (CBC, GCM) | 128, 192, 256 bits | File encryption, secure communication | `Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");`<br>`cipher.init(Cipher.ENCRYPT_MODE, secretKey, new GCMParameterSpec(128, iv));`<br>`byte[] encrypted = cipher.doFinal(data);` |
| RSA | Asymmetric<br>• Slower than AES<br>• Widely supported<br>• Used with AES for hybrid encryption | 2048, 3072, 4096 bits | Key exchange, digital signatures | `Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");`<br>`cipher.init(Cipher.ENCRYPT_MODE, publicKey);`<br>`byte[] encrypted = cipher.doFinal(data);` |
| ECC (Elliptic Curve) | Asymmetric<br>• Smaller keys than RSA<br>• Same security with less overhead<br>• Better for constrained devices | 256, 384, 521 bits | Mobile apps, smart cards, IoT | `KeyPairGenerator keyGen = KeyPairGenerator.getInstance("EC");`<br>`keyGen.initialize(new ECGenParameterSpec("secp256r1"));`<br>`KeyPair keyPair = keyGen.generateKeyPair();` |
| SHA-256, SHA-512 | Hash<br>• One-way function<br>• SHA-2 family<br>• Collision resistant | N/A | Password storage, data integrity | `MessageDigest digest = MessageDigest.getInstance("SHA-256");`<br>`byte[] hash = digest.digest(data);` |
| HMAC | MAC<br>• Hash-based message authentication<br>• Requires shared key<br>• Protects against tampering | Varies | API authentication, message integrity | `Mac mac = Mac.getInstance("HmacSHA256");`<br>`mac.init(secretKey);`<br>`byte[] hmac = mac.doFinal(data);` |
| PBKDF2 | Key Derivation<br>• Password-based key derivation<br>• Uses iterations to slow attacks<br>• Configurable computation cost | Varies | Password hashing | `SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");`<br>`KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, 10000, 256);`<br>`byte[] hash = factory.generateSecret(spec).getEncoded();` |
| Bcrypt | Password Hashing<br>• Adaptive hash function<br>• Built-in salt<br>• Automatically adjusts cost factor | N/A | Password storage (adaptive) | `// Using jBCrypt library`<br>`String hash = BCrypt.hashpw(password, BCrypt.gensalt(12));`<br>`boolean match = BCrypt.checkpw(password, hash);` |

## Security Best Practices

| Practice | Description | Example |
|----------|-------------|---------|
| Secure Storage | Protect sensitive data at rest.<br>• Use char[] instead of String for passwords<br>• Clear sensitive data after use<br>• Consider secure hardware when available | `// Don't:`<br>`String password = "secret"; // Stored in memory as plain text`<br><br>`// Do:`<br>`char[] password = getPasswordFromUser();`<br>`// Use the password for authentication`<br>`Arrays.fill(password, ' '); // Clear after use` |
| Forward Secrecy | Ensure encrypted data remains secure if keys are compromised.<br>• Use ephemeral keys<br>• Implement key rotation<br>• Support modern cipher suites | `// Use ephemeral keys with ECDHE in TLS`<br>`SSLContext context = SSLContext.getInstance("TLS");`<br>`context.init(null, null, null);`<br>`SSLParameters params = context.getDefaultSSLParameters();`<br>`params.setCipherSuites(new String[] {"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384"});` |
| Authenticated Encryption | Protect confidentiality, integrity, and authenticity.<br>• Use AEAD modes like GCM<br>• Combines encryption with authentication<br>• Protects against padding oracle attacks | `// Using AES-GCM (provides authentication and encryption)`<br>`GCMParameterSpec gcmSpec = new GCMParameterSpec(128, iv);`<br>`Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");`<br>`cipher.init(Cipher.ENCRYPT_MODE, secretKey, gcmSpec);`<br>`cipher.updateAAD(additionalData); // Add authenticated but unencrypted data`<br>`byte[] ciphertext = cipher.doFinal(plaintext);` |
| Certificate Pinning | Verify server certificate against known certificate.<br>• Prevents MITM attacks<br>• Reduces trust on CAs<br>• Requires maintenance for cert rotation | `// OkHttp example`<br>`String hostname = "example.com";`<br>`CertificatePinner certificatePinner = new CertificatePinner.Builder()`<br>`    .add(hostname, "sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=")`<br>`    .build();`<br>`OkHttpClient client = new OkHttpClient.Builder()`<br>`    .certificatePinner(certificatePinner)`<br>`    .build();` |
| Avoid Common Vulnerabilities | Protect against known attack vectors.<br>• Prevent SQL injection<br>• Defend against XSS<br>• Implement CSRF protection | `// SQL Injection - Use PreparedStatement`<br>`String sql = "SELECT * FROM users WHERE username = ?";`<br>`PreparedStatement stmt = conn.prepareStatement(sql);`<br>`stmt.setString(1, username);`<br>`ResultSet rs = stmt.executeQuery();`<br><br>`// XSS - Encode output`<br>`String encoded = StringEscapeUtils.escapeHtml4(userInput);`<br><br>`// CSRF - Use tokens`<br>`String csrfToken = UUID.randomUUID().toString();`<br>`session.setAttribute("csrfToken", csrfToken);`<br>`model.addAttribute("csrfToken", csrfToken); // Add to form` |
| Secure Coding | Follow secure development guidelines.<br>• Validate all inputs<br>• Apply least privilege principle<br>• Fail securely and handle errors properly | `// Input validation`<br>`if (!Pattern.matches("[a-zA-Z0-9]{5,15}", username)) {`<br>`    throw new IllegalArgumentException("Invalid username");`<br>`}`<br><br>`// Principle of least privilege`<br>`@RolesAllowed("ADMIN")`<br>`public void adminMethod() { /* ... */ }`<br><br>`// Fail securely`<br>`try {`<br>`    // Security operation`<br>`} catch (Exception e) {`<br>`    log.error("Security operation failed", e);`<br>`    throw new SecurityException("Access denied");`<br>`}` |

## OAuth 2.0 and JWT

| Concept | Description | Example |
|---------|-------------|---------|
| OAuth 2.0 | Authorization framework for third-party access.<br>• Standardized authorization protocol<br>• Different grant types for various scenarios<br>• Separates authentication from authorization | `// Spring Security OAuth2 Client`<br>`@EnableWebSecurity`<br>`public class SecurityConfig extends WebSecurityConfigurerAdapter {`<br>`    @Override`<br>`    protected void configure(HttpSecurity http) throws Exception {`<br>`        http`<br>`            .oauth2Login()`<br>`            .and()`<br>`            .authorizeRequests()`<br>`            .anyRequest().authenticated();`<br>`    }`<br>`}`<br><br>`# application.yml`<br>`spring:`<br>`  security:`<br>`    oauth2:`<br>`      client:`<br>`        registration:`<br>`          github:`<br>`            client-id: your-client-id`<br>`            client-secret: your-client-secret` |
| JWT (JSON Web Token) | Compact token format for claims transfer.<br>• Self-contained with all necessary information<br>• Digitally signed to ensure integrity<br>• Base64 encoded in three parts (header.payload.signature) | `// Creating JWT with JJWT`<br>`String jwtToken = Jwts.builder()`<br>`    .setSubject(username)`<br>`    .claim("roles", roles)`<br>`    .setIssuedAt(new Date())`<br>`    .setExpiration(Date.from(Instant.now().plus(1, ChronoUnit.HOURS)))`<br>`    .signWith(SignatureAlgorithm.HS256, secretKey)`<br>`    .compact();`<br><br>`// Parsing JWT`<br>`Jws<Claims> claims = Jwts.parser()`<br>`    .setSigningKey(secretKey)`<br>`    .parseClaimsJws(jwtToken);`<br>`String subject = claims.getBody().getSubject();` |
| Token-based Authentication | Stateless authentication using tokens.<br>• No server-side session storage needed<br>• Improves scalability<br>• Well-suited for microservices architecture | `// Spring Security JWT Filter`<br>`@Component`<br>`public class JwtAuthenticationFilter extends OncePerRequestFilter {`<br>`    @Override`<br>`    protected void doFilterInternal(HttpServletRequest request, `<br>`                                 HttpServletResponse response, `<br>`                                 FilterChain filterChain) throws IOException, ServletException {`<br>`        String token = extractToken(request);`<br>`        if (token != null && validateToken(token)) {`<br>`            Authentication auth = getAuthentication(token);`<br>`            SecurityContextHolder.getContext().setAuthentication(auth);`<br>`        }`<br>`        filterChain.doFilter(request, response);`<br>`    }`<br>`}` |
| OpenID Connect | Authentication layer on top of OAuth 2.0.<br>• Adds identity layer to OAuth<br>• Standardized user information format<br>• Simplifies integration with identity providers | `// Spring Boot OIDC Configuration`<br>`@EnableWebSecurity`<br>`public class SecurityConfig extends WebSecurityConfigurerAdapter {`<br>`    @Override`<br>`    protected void configure(HttpSecurity http) throws Exception {`<br>`        http`<br>`            .authorizeRequests()`<br>`            .anyRequest().authenticated()`<br>`            .and()`<br>`            .oauth2Login()`<br>`            .userInfoEndpoint()`<br>`            .oidcUserService(oidcUserService);`<br>`    }`<br>`}` |